= Upmpdcli
:toc: left

== Introduction

link:https://www.lesbonscomptes.com/upmpdcli:[Upmpdcli] is primarily an UPnP Renderer, using the MPD
music player for audio stream processing. It has a number of additional or alternative functions
exposed through an UPnP Media Server.

Do not scrap your old amp yet, with 100 Euros (a Raspberry Pi and a high quality DAC I2S
daugtherboard) you can transform it into a state of the art network streamer.

The xref:UPNP[next section] explains the network audio terms (UPnP, Media Renderer, etc.) if your
knowledge needs a little brushing up. Else, you can jump to the xref:UPMPDCLI-OVERVIEW[upmpdcli
overview] section.


=== Security

WARNING: The UPnP protocols have no security
provisions. Upmpdcli is not audited for security issues, and, as far as I
know, it is full of exploitable bugs. Do not run it on an Internet-facing
host.


[[UPNP]]
== UPnP and all that

=== UPnP AV

UPnP is a family of network protocols, designed for easily connecting
_stuff_ in home networks (mostly). Its name ("Universal Plug and Play") was
chosen because little or no configuration is needed for the different
elements to discover each other and play together.

The UPnP audio/video section (UPnP AV) implements a way for data stored on
a network host (PC, NAS, etc.) to be displayed on another one (TV, audio
streamer, etc.).

Generally, there are four building blocks in a network audio solution:

- An audio File/Data server stores the (bulky) audio data and makes it
  available to clients using an appropriate protocol (NFS, SMB, HTTP,
  etc. depending on client).
- The directory/tags manager extracts audio tags from the files (usually
  accessing them directly or through a network file sharing protocol), and
  builds a database used for searching or browsing the collection.
- Audio players (renderers) take encoded audio data and actually make
  sound, using some kind of DAC (Digital Analog Conversion) device, such as
  an internal or USB sound card.
- The user interface is a remote control which sits in your hand (or it's
  the PC in front of you). You use the application which runs on it to
  choose songs from the database and control the playback. It interacts
  both with the tags database and player parts (usually not with the file
  server, except maybe to fetch cover art).

.Network Audio
image::pics/netaudio.png["Network Audio Elements"]

In the UPnP world:

 - The tags manager is named Media Server (more precisely, the Content
   Directory service inside the Media Server device). Data is usually
   stored on the Media Server, but it could also live elsewhere. Data
   access is almost always performed through HTTP.
 - The player is named Media Renderer. It usually does not implement much
   user interface.
 - The remote control is named Control Point
  
The good people who specified UPnP AV got something wrong: the playlist
is owned by the Control Point, not by the Renderer. This means that the
Renderer will not play the next track if the Control Point goes to sleep,
and that havoc is almost guaranteed if several Control Points try to share
a Renderer. This is the main reason for using OpenHome (see <<OPENHOME,next>>).

[[OPENHOME]]
=== OpenHome

The link:http://wiki.openhome.org/wiki/OhMediaDevelopers[OpenHome] family
of open protocols were designed by link:http://www.linn.co.uk/[Linn] to correct
the weaknesses in UPnP AV. They implement extended services over the base
UPnP mechanisms.

Principally, the OpenHome playlist lives on the Renderer. It will continue
playing if the Control Points goes to sleep, and it can be shared. This is
a compelling advantage and most well-known Control Points (e.g. BubbleUPnP,
Kazoo, PlugPlayer...) support OpenHome.

Beyond this, OpenHome also defines additional services, for example for
accessing Internet radios. The different possible origins of audio data
inside an OpenHome Renderer are named _Sources_, e.g. Radio Source,
Playlist Source. Sources are switchable from any Control Point supporting
OpenHome.

OpenHome Sources are designated by a type and name, and a Renderer can have
any number of them (for example, Upmpdcli uses additional sources to
control its Sender mode).

=== Songcast 

link:https://docs.linn.co.uk/wiki/index.php/Songcast[Songcast] is an open protocol designed by Linn
for real-time network audio, allowing synchronized playing on multiple sources. Its only
relationship with UPnP is that UPnP services are used to control the connections. Songcast allows
playing the same audio on multiple players, with almost perfect synchronization, or capturing audio
on a computer to play it on another system.

The protocols links two types of entities:

 - A Songcast Sender generates an audio stream.
 - One or several Songcast Receivers receive and play the stream.

Linn used to supply free audio capture drivers functionning as Songcast Senders, for MS-Windows and
Mac OS X.  This enabled playing the audio of *any* application (Windows Media Player, Spotify, etc.)
onto one or several Songcast Receivers, without any need for the applications to know about
Songcast. These drivers are now discontinued, apparently due to changes in the OS security
models. However, Songcast can still be useful for synchronized playing on multiple Songcast-aware
players, Linn or other.

=== Gapless ?
 	
This is a relatively small issue, but people are very sensitive to it, it is important from some
music pieces and you will hear about it all the time if you read forums, so, a quick explanation
follows.

Some music tracks need to flow into each other when played consecutively, for example tracks on some
live albums (the background noise from the audience never stops), or some classical music pieces.

When playing from separate audio files, it is not trivial for a renderer to ensure a seamless flow:
the audio hardware has an input pipe which must be kept full at all times, else it will stop, and a
period of silence will ensue: not gapless !

To avoid this, the renderer has to know in advance which file it will process after the current one,
to be able to begin filling the audio pipe with data from the next track before it empties at the
end of the current one.

There are two ways that this can be achieved: either the renderer is also in charge of the play
queue, so it knows the whole sequence all the time (e.g. MPD, OpenHome, â€¦), or the controller
indicates the next track to the renderer before the current track finishes (e.g. UPnP/AV
SetNextTransportURI).


[[UPMPDCLI-OVERVIEW]]
== Upmpdcli overview


link:https://www.lesbonscomptes.com/upmpdcli:[Upmpdcli] was originally
xref:UPMPDCLI-RENDERER[primarily an UPnP Media Renderer], using a slave MPD to actually process the
audio data. The renderer supports UPnP gapless track transitions and the OpenHome ohMedia services
(including a Radio service to listen to Internet streams).

.The Grand Upmpdcli Media Renderer Scheme of Things
image::pics/upmpdcli.png["The Grand Scheme of Things"]

Additionally:

- The *upmpdcli* program also implements a xref:UPMPDCLI-MS[Media Server]. This function is hosted
  in the same program (and usually runs in separate threads of the same process), but it is
  completely independant: *upmpdcli* can run as Renderer only, or Media Server only, or both, and
  the Media Server can be accessed by any Control Point and serve streams to any Renderer, not only
  to its co-hosted one. The Upmpdcli Media Server implements gateways to external streaming services
  (Highresaudio, Qobuz, Deezer...), and also includes the xref:UPMPDCLI-MS-UPRCL[*uprcl*] module,
  which provides a Media Server for local audio files. *uprcl* is based on the
  link:https://www.recoll.org[Recoll] medata extraction and search functions.

- Upmpdcli implements control functions for the Linn Songcast protocol, allowing the local machine
  to behave as a Songcast Receiver or Sender (with help from the closely related *sc2mpd* package,
  for processing the audio streams). 


Upmpdcli can be installed on most Linux systems. It is frequently used on small single board
computers like the Raspberry Pi. As far as I know, all audio-oriented distributions currently use it
as their UPnP Media Renderer interface, and it is also present in a number of commercial devices.

If some cases, Upmpdcli can operate without a configuration file, as a few of the main parameters
can be set on the xref:COMMAND-ENVIRON[command line or in the environment].

Most parameters can only be set in the configuration file, though. The file is designated with the
`-c` command line option. The usual location is `/etc/upmpdcli.conf`.

The configuration file has a simple `name = value` format, and is fully described in the
<<UPMPDCLI-CONFIGURATION,configuration reference section>>.

upmpdcli has many configuration parameters, which may make the configuration intimidating. However,
most parameters only relate to one function of the program and they are grouped in sections, many of
which are probably not relevant to you. In each section, the most important parameters are presented
first, and you probably will never need to bother with the bottom of the list.

The <<UPMPDCLI-CONFIG-GUI,upmpdcli-config graphical tool>> can help you edit the configuration file,
it can present the same information as this manual, directly linked with the controls used to modify
the parameters.

Upmpdcli can be run as root. In this case it will change its user id to `upmpdcli` after some
initialisation and permissions setup for its data cache, usually under `/var`. The process can also
be started by any regular user, in which case it will store its data under `~/.cache/upmpdcli`.




[[UPMPDCLI-RENDERER]]
== Upmpdcli Media Renderer


////
// Note about configuration section refs: only the first parameter in a
// subsection can be referenced, and it references the whole
// subsection. Hence refs like <<mpdhost,`mpdport`>>, which are not typos
////


This section goes in a little more detail about miscellaneous aspects of
the Media Renderer, and describe a few of the most used configuration
parameters. See the <<UPMPDCLI-CONFIGURATION,configuration reference section>>
for more details (I would very much like to link each parameter to its
definition but Asciidoc won't let me do it, so they link to the top of the
appropriate section.).

If several instances of *upmpdcli* run on the same network, you will want
to give them distinct names. The name which is displayed by most Control
Points can be set with the <<friendlyname,`friendlyname`>> configuration
parameter. Some Linn Control Points (e.g. Kazoo) use another value, set
with <<ohproductroom,`ohproductroom`>>.

Upmpdcli usually controls the MPD instance running on the same
host. However, there may be reasons to do otherwise, and the host name and
port where mpd should be reached can be set with <<mpdhost,`mpdhost`>>,
and <<mpdhost,`mpdport`>>.

The Upmpdcli Media Renderer has two active interfaces by default: UPnP AV
and OpenHome. Only OpenHome Control Points can share the renderer. If you
use an UPnP AV Control Point, it must be the only one. This is not
enforced, and misuse will result in miscellaneous weirdnesses. In some
special situations, it may be useful to limit the interface to UPnP AV or
OpenHome only (or disable both), which can be done with the
<<friendlyname,`openhome`>> and <<friendlyname,`upnpav`>> parameters.

[[UPMPDCLI-RENDERER-FORMATS]]
=== Audio formats

Upmpdcli can accept most audio formats supported by MPD, meaning about
anything, including DSD.

Upmpdcli normally checks that the format of a resource to be played is
compatible with what it thinks MPD can do. This check is sometimes
pessimistic and can be disabled by setting
<<friendlyname,`checkcontentformat`>> to 0.

You should know that MPD has difficulties with some formats _when accessed
through HTTP_ which is how the Media Server transfers the data.

Specifically, WAV and AIFF files, especially with samples wider than 16
bits are a frequent source of trouble (because they are little used and
little tested for streaming). Support will vary depending on the MPD
versions and exactly what input plugins are configured (among *ffmpeg*,
*libaudiofile* and *libsndfile*). Often, the same files play just fine
locally, it's the combination of HTTP access and file format which causes
problems.

Raw PCM streams are another special case. The reason is that these streams
do not, by definition, carry metadata to define the exact format (sample
rate, bits per sample, number of channels, byte order). *upmpdcli* has no
way to transfer these parameters to *MPD* (this is a limitation of the
client protocol). The parameters can be transferred from the Media Server
to the player along with the MIME type though. In consequence, only recent
versions of Upmpdcli and MPD (0.20 and later) do support audio/L16, but
not with any Media Server (it must output the audio formats
parameters with the MIME type). See this issue for more details:
https://www.lesbonscomptes.com/upmpdcli/github-issues/upmpdcli-html/issue-36.html

In general, there are few reasons to use these linear formats, when FLAC
will produce exactly the same bits, with less network load (which largely
compensates the small additional CPU load).

There are situations where the linear formats are needed though, and where
it may be necessary to use the right MPD and plugins versions.

[[radio-stations]]
=== Radio stations

Upmpdcli implements an OpenHome Radio service which allows selecting and
listening to internet radio stations when using an OpenHome-compatible
Control Point (e.g. Kazoo, Lumin, Bubble UPnP, etc.).

This facility uses Python 3.x, which must be available on the system for
the radio links to work.

Radio channels can be accessed by using the Control Point application to
select the _Radio_ OpenHome source.

Radio stations can be defined in the configuration (at the end because of
the use of section indicators), or in in a separate file by setting the
<<ohproductroom,`radiolist`>> parameter in the main configuration.

In both cases, a radio definition entry will look like the following:

----
[radio Radio Eins]
url = http://opml.radiotime.com/Tune.ashx?id=s25111
artUrl = http://cdn-radiotime-logos.tunein.com/s25111q.png
----

A radio is defined in a configuration section with a name beginning with `radio`
(e.g. _[radio{nbsp}my{nbsp}radio{nbsp}name]_). The `radio` string is mandatory and allows the
section to be recognized as a radio definition.

Inside the section, the only mandatory entry is the `url`
one, which should point either to the actual audio stream, or to the station playlist link which
will redirect to it.

You can also set `artUrl` to point to a static icon image for the radio station.

The upmpdcli OpenHome radio source also has the capability to display cover art and metadata for the
currently playing stream, if the Internet radio makes it available. This is implemented by executing
a script to fetch the appropriate data.

See the <<RADIO-SCRIPTS,radio scripts section>> for more detail.

[[UPMPDCLI-SONGCAST]]
== Upmpdcli and Songcast

Upmpdcli implements the Receiver UPnP service, and uses an auxiliary
process (*sc2mpd*) for transporting the audio data. *sc2mpd* is based
on the sample program which comes with the Linn Songcast
OpenHome open source implementation

Upmpdcli can also manage a Sender subsystem, which is implemented by using
a separate *mpd* instance sending audio to an *mpd2sc* command (part of the
*sc2mpd* package). The latter is a modified version of the OpenHome
WavSender sample program. This allows playing the usual Upmpdcli playlist
or a a radio channel on several synchronized players, but also doing the
same thing with a captured analog source (e.g. *arecord* output).

NOTE: You should know that it is possible to control the Songcast Sender
from another local network PC to snoop on what you are listening (Radio or
Playlist). This is detectable from the Renderer state, but not obvious. In
any case, the playlist itself is public (there are no privacy provisions in
UPnP), so this is probably not a major additional issue. The system will
not capture anything besides what *mpd*, or an explicitely setup additional
source are playing (e.g. Skype phone conversations are out of reach).

[[UPMPDCLI-SONGCAST-COMPAT]]
=== Songcast Control Point compatibility

Upmpdcli Senders and Receivers can be mixed with Linn ones and controlled
from Upplay or Bubble DS (an maybe other control points).

Neither Linn nor upmpdcli receivers can be linked to an upmpdcli Sender using 
Linn Kazoo (tested with release 4.11.226), the reason is unknown.

Upmpdcli Receivers before release 1.2.14 are not visible in Linn
Kazoo. Later versions can be linked, and stream, from a Linn Sender.

Linn Kazoo can control the playlist in an upmpdcli instance which has been
put in Sender mode by another CP (i.e. currently using the PL-To-Sender
source). The Lumin IOS app will reset the Source to Playlist when
connecting, so it is unusable in this context.

[[UPMPDCLI-RECEIVER]]
=== Songcast Receiver

*sc2mpd* can play the *Songcast* audio stream in two modes:

 - By directly using the *alsa* audio driver.
 - By using *mpd* to play the stream offered from a local HTTP interface
   (hence the *sc2mpd* name)

.Upmpdcli Receiver in `alsa` and `mpd` modes
[options="header"]
|=============
|`alsa`|`mpd`
|image:pics/upmpdcli-receiver-alsa.png[Upmpdcli Receiver, alsa mode]|image:pics/upmpdcli-receiver-mpd.png[Upmpdcli Receiver, mpd mode]
|=============

What approach is used is decided by the <<sclogfilename,`scplaymethod`>>
configuration parameter, which can be set to _mpd_ or _alsa_. 

The _mpd_ mode is the default, because it needs no configuration, but there
are *multiple* problems with it. If you go the _alsa_ route,
you will need to set <<sclogfilename, `scalsadevice`>> in the
configuration, but you probably had to set it in the MPD configuration too,
so this may not be too much of an issue.
 
NOTE: when using the _alsa_ approach, *sc2mpd* will open the audio driver
directly. The *sc2mpd* process is started by *upmpdcli*, which normally
runs with user id _upmpdcli_. A frequent cause preventing the Receiver from
working is that the driver open fails because _upmpdcli_ user has no
permission to access it. One solution is to create an _audio_ group (if it
does not exist), make the devices writable by _audio_, and add _upmpdcli_
(and others) to the _audio_ group.

When using *mpd*, more bufferisation occurs and there may be a significant
delay (up to around 10&nbsp;S) between the time when Songcast is activated
and the time sound appears.

NOTE: When using _mpd_, from a Mac (24 bits audio) you need an
appropriately configured and recent MPD version (usually configured with
`--disable-audiofile`), else you risk producing high volume noise.  As
Debian and Ubuntu tend to lag quite bit on MPD progresses, I have set up
link:https://www.lesbonscomptes.com/upmpdcli/pages/downloads.html#mpd[backport
repositories] for appropriately configured recent mpd versions, for Ubuntu,
Debian i386/amd64 and Raspbian. Unfortunately, not only the MPD version is
significant, there are sometimes also problems in the input plugins
libraries.

Given the bufferisation and delay control issues when going through MPD,
only the _alsa_ method is usable in multi-room configurations. Even with a
single player, the _mpd_ method will experience skips from time to
time. The reasons are explained in the xref:UPMPDCLI-MULTIROOM-SYNC[multiroom
synchronization section]. 

The following steps are taken for establishing a Songcast connection:

- If *upmpdcli* finds an executable *sc2mpd* command in the PATH when
  starting up, it advertises a Receiver service.

- The *Songcast* application on the desktop finds out about the
  Receiver through the normal UPnP mechanisms and can be instructed to
  use it. It then tells the Receiver in *upmpdcli* to start playing.

- *upmdpcli* starts the *sc2mpd* process, which gets ready to receive data
  through Songcast, and either play it directly or make it available
  through HTTP.

- If the _`mpd`_ method is in use, *upmpdcli* instructs *mpd* to play the
  URL for the *sc2mpd* output.

NOTE: Songcast can use IP multicast for lower load on the network when
playing on several hosts. Unfortunately, multicast and WIFI don't mix well
in many cases. If you have wireless Receivers experiencing sound drop
issues, try selecting unicast in the Songcast advanced configuration panel
on the desktop.

[[UPMPDCLI-RECEIVER-VOLUME]]
=== Songcast Receiver Volume control

This section used to claim that the *upmpdcli* Songcast Receivers
implemented no software volume control and that you needed to use either a
local mixer or the little round things on the pre-amps.

Actually, as of *sc2mpd* version 1.1.6, there are two possible ways to
control the volume on an upmpdcli Songcast receiver, one of which has
existed for a long time. Both approaches are based on the fact that a
control point connected to the upmpdcli instance can set the volume level
using the normal UPnP/OpenHome interfaces.

The first method, which has been available for a long time is to use the
<<onstart,`externalvolumecontrol`>> feature, and set up the corresponding
scripts to set and retrieve the volume from the audio mixer (e.g. using
amixer or such). This will adjust the volume without any change to the
Songcast stream.

The second method, available for *sc2mpd* versions 1.1.6 and later can
scale the audio stream according to the local *mpd* volume setting.  The
volume control goes from the control point to *upmpdcli*, which sets it in
*mpd*, from which *sc2mpd* retrieves it to set the scale factor. This is
not active by default, you can enable it by setting the <<sclogfilename,
`scusempdvolume`>> variable to 1 in the local `upmpdcli.conf`. This only
works if if `scplaymethod` is _alsa_.

[[UPMPDCLI-SENDER]]
=== Songcast Sender

Upmpdcli Sender mode allows you to broadcast the Playlist or Radio source
(or the output of any process which can write to a Fifo, e.g. *arecord*) to
other Songcast Receivers. The local *upmpdcli* plays through its Receiver
too, in order to achieve good synchronisation. Unlike the Songcast
applications on Windows or Mac, the audio is not captured from the driver,
so that you won't be able to cast other applications transparently (but
there are specific workarounds).

You can set *umpdcli* in Sender mode from an OpenHome Control Point, by
selecting the Source of type `Playlist`, name `PL-to-Songcast` or type
`Radio`, name `RD-to-Songcast` (and others if using the extension
mechanism).  With
link:http://www.lesbonscomptes.com/upplay/index.html[upplay], for example,
you can select the source from the `File`->`Select Source` menu entry.

The *sc2mpd* configuration *must* be set with `scplaymethod = alsa` for the
`XX-to-Songcast` sources to appear. See the
xref:sclogfilename[configuration section], and the
xref:UPMPDCLI-MULTIROOM-SYNC[section about synchronisation].

When entering Sender mode, *upmpdcli* will start an auxiliary MPD process
(after stopping the main one), configured to send audio to the *mpd2sc*
OpenHome Sender process. It will then also start its own Songcast
Receiver mode, transfer the playlist, stop the main MPD and start the
auxiliary one...

The resulting state is that the *upmpdcli* instance can be managed in
Playlist mode from the Control Point. The audio is played locally through
the Songcast Receiver. Other Receivers can be connected and will play in
good synchronization.

image::pics/upmpdcli-sender-receiver.png["Sender/Receiver mode"]

This looks complicated, but in practise, starting the mode and connecting
other Receivers from the *upplay* control panel is quite straightforward.

[[UPMPDCLI-SENDER-EXTSOURCES]]
==== Managing external sources

In the Sender modes described above, *upmpdcli* (or rather its slave *mpd*
process) is the source of the audio stream. The *mpd2sc* program (which is
just a slight modification of a Linn sample) reads the *mpd* output from 
a FIFO and sends it to Songcast Receivers (including the local one).

There is nothing special with the *mpd* output (it is just PCM audio), and
it is also possible to set things up for *mpd2sc* to read from another
source.

This is made reasonably easy because the pipe is actually built by
a script (the default one is named 'scmakempdsender'), and *upmpdcli* has
built-in functionality for choosing different ones (creating OpenHome
sources for each script it finds in a specific directory). There is a
sample script in the distribution, which itself is flexible enough to allow
connecting several inputs without programming (anything *arecord* can read).

Still the details are a bit too much involved for the main body of the
manual, so I have moved them to an xref:SENDER-EXTSOURCES[annex].

[[UPMPDCLI-MULTIROOM]]
=== Songcast multiroom configurations and synchronization issues

Multiple Songcast Receivers can connect to the same Sender, for
synchronized playing of a the same audio stream.

The Mac and Windows Songcast applications only let you activate one Receiver.

The easiest way to manage multiple connections is to use an appropriate
control point, such as Upplay on Linux and Windows, BubbleDS on Android, or
Linn Kazoo (multiple platforms).

For the record, the *upmpdcli* package also includes the *scctl* command
line utility, which can list the state of the local Songcast Receivers,
make a Receiver play from the same URI as another one (for building
multi-room groups), or return a Media Renderer from Receiver to normal
operation. There is also a xref:SCWEB[small Web application] which can be
accessed from a desktop web browser to control the groups. This has only
be tested with *upmpdcli* as Receiver implementation, but I'd guess that
there is a good chance it would work with others. Quite frankly, I think
that you'd better use the Control Point approaches if at all possible.

[[UPMPDCLI-MULTIROOM-SYNC]]
==== Synchronisation issues

The short version is: for good synchronization, all *sc2mpd* instances
must be configured to play directly to the audio driver with `scplaymethod
= alsa`. See the xref:sclogfilename[configuration section].

Longer version: *Songcast* is a real-time audio stream. As the Sender and
Receiver sample clocks (the 44.1 or 48 KHz clocks) are independant, audio
reproduction on the two systems will slowly drift. If nothing is done,
after a time, the Receiver will have to skip samples or add a period of
silence (depending if its clock is slower or faster), which is quite
audible and ennoying, and will happen "from time to time", depending of how
much the clocks differ.

The only way to control this is to adjust the rate of reproduction on the
Receiver, which can be done in two ways:

 - *Linn* hardware uses timestamps embedded in the audio stream to adjust
   their hardware sample clock.
 - *sc2mpd* in _alsa_ mode uses sample rate conversion to adjust the stream.
 - *sc2mpd* in _mpd_ mode can't do a thing about it.
 
This is not specific to *Songcast* of course, all real time audio network
transports have to do something similar (e.g. Roon does individual stream
adjustments on the server).

Independantly of the clock issue, all Receivers should use approximately
the same amount of buffering for the audio to be reasonably synchronous
(with no more shifts than moving around would produce anyway). This is
impossible to achieve when going through *mpd*, and the second reason why
*sc2mpd* must be set in _alsa_ mode for multiroom setups. In _mpd_ mode,
the Receivers can be out of sync by several seconds.

[[UPMPDCLI-MS]]
== Upmpdcli Media Server

=== Overview

The *upmpdcli* Media Server provides a number of separate functions, which can be activated through
the configuration file.

- The xref:UPMPDCLI-MS-UPRCL[uprcl] plugin enables access to your local audio media collection.

- The xref:UPMPDCLI-MS-SUBSONIC[subsonic] plugin proxies access from a Subsonic/Navidrome server to
  UPnP.

- Several xref:UPMPDCLI-MS-STR[plugins] function as gateways for commercial streaming services such
  as Qobuz.

- And other plugins provide various functions: an xref:UPMPDCLI-MS-UPRADIOS[access to the upmpdcli
  internet radio list], access to the xref:UPMPDCLI-MS-BBC[BBC Sounds service], or the
  xref:UPMPDCLI-MS-RADIO-BROWSER[Radio Browser] Web radios catalog...

When at least one plugin is activated, *upmpdcli* creates a separate auxiliary Media Server. By
default, the Media Server name is the `friendlyname` for the Upmpdcli instance, with _-mediaserver_
appended, but this can be changed in the xref:msfriendlyname[configuration].

In general, a plugin is activated by being installed, and having its user name defined in the
configuration file (e.g. for a plugin named _myplugin_ `mypluginuser = somevalue`). Depending on the
plugin, the variable value maybe real (e.g. a Qobuz user name), or bogus and unused. 

A description of each of the plugins follows. Some of them need the additional installation of
Python extensions from Pypi. These should be done globally, or in some alternate way ensuring that
they are visible to the boot-started `upmpdcli`. If a given dependency is packaged by your
distribution, it may have been installed with the plugin.YMMV: look at the error output with, e.g.
`journalctl` if things do not work.

'''
[[UPMPDCLI-MS-UPRCL]]
=== Uprcl Media Server

The Upmpdcli application includes a Media Server function for local music files, analog to
MinimServer or ReadyMedia/MiniDLNA. The plugin module is named *uprcl*.

Enable this function by installing the upmpdcli *uprcl* module (which may be a separate package,
e.g. `upmpdcli-uprcl` on Debian), and uncommenting the bogus setting for the `uprcluser` variable in
the upmpdcli configuration file. You may also want to set `uprclautostart` to 1 so that
initialisation is performed as soon as the program start, and not on the first access. Also: you
need to install link:http://www.recoll.org[Recoll] (just the command line and Python3 extension are
needed) if your package manager did not do it for you. If you are using the upmpdcli repositories
(on Launchpad for Ubuntu or the lesbonscomptes server for Debian), this will happen automatically.

NOTE: 'python3-mutagen' which is optional for default Recoll installations is required for uprcl
(this is for the case where you install by hand, the package takes care of it).

NOTE: uprcl needs Python 3.5 at least. This means that it does not work on Debian Jessie (8.x)

Why yet another Media Server ? Mostly because my favorite, MinimServer is great, and free, but not
open-source, so I find it prudent to have an alternative. Also, fun :)

*uprcl* only implements a small fraction of MinimServer vast list of capabilities at this point, but
it's slowly making progress, and I find it works well enough, at least with the upmpdcli renderer,
to now be my main Media Server.

Some *uprcl* features:

- Mostly written in Python (python3), except for the part shared with the streaming media server
  plugins, which is in C++.
- Tries to mimick the MinimServer tree view and functionality. We're not quite there yet, many
  functions and niceties are still missing.
- Uses Recoll and python3-recoll (hence the uprcl name) for harvesting the metadata and searching.
- Uses Python3 Sqlite3 (on a memory DB) for the tags tree. 
- Can retrieve some parameters from the MinimServer configuration file. Will support more in the
  future.

The list of MinimServer functions which are _not_ supported would be too long. Here follows what
*uprcl* does support, at least partially:

- `contentDir` will be used if `uprclmediadirs` is not set in
  '/etc/upmpdcli.conf' 
- `excludePattern`
- `aliasTags`
- `indexTags`
- `showExtras`
- Multidisc albums (partial).

All in all, not a lot of the customization options are supported for now. I'd love feedback about
what is missing most.

Installation and configuration: have a look at the xref:uprcluser[configuration variables]

The server also starts a minimal Web interface displaying the current running status and allowing to
ask for an incremental or full scan of the media directories. By default, this runs on port 9090.


[[UPMPDCLI-MS-UPRCL-SEARCH]]
==== Upmpdcli/Uprcl searches

The UPnP Media Server search function is based on a specific query
language. This language is quite verbose, and most control points will not
let you access it directly. Instead, they will usually provide a generic
entry field in which you enter search terms.  Behind the scenes, they
generate an UPnP search language string. This could be for example
something like: `upnp:class = "object.item.audioItem" and dc:title
contains "heaven"`

If it supports search at all, the Media Server will then interpret the
query string and return the results.

If the Media Server is Upmpdcli/Uprcl, there is another step: the UPnP
query string is translated into a Recoll one and Recoll is called to
perform the actual search. There is no way to directly enter a Recoll
search through the control point. However, two important Recoll
capabilities should still be visible through the layers:

.Stemming

Stemming is the capability to expand a search to the common derivatives of
a word. For example, a search for `floor` would be expanded to also look
for `floors`, `flooring`, `floored`, etc. By default, stemming is enabled
for Uprcl search. It can be turned off for any term by capitalizing the
term (Entering `Stones` will only search for `stones`, not `stone` or
`stoned`). Uprcl/Recoll searches are case-insensitive apart from this usage
of capitalization.

.Phrase searches

By default, Uprcl/Recoll searches do not observe the order
of terms: `red house` will be matched by a search for `house red` (or
`houses red`). You can change this behaviour by quoting a sequence of
words. A search for `"red house"` will only look for a text containing the
words in order. This supposes that the Control Point does not change the
user entry, but this is the case for at least some of them. Stemming
expansion does not occur within phrase searches.

Other Recoll capabilities, such as proximity searches should also be
accessible, but probably less useful when searching music titles or artist
names.

'''
[[UPMPDCLI-MS-SUBSONIC]]
=== SubSonic plugin

The plugin allows access to a SubSonic server.  Specifically, it has been tested against a
link:https://www.navidrome.org[Navidrome] instance, but there is nothing Navidrome-specific in the
code.

NOTE: The plugin needs the installation of two additional Python packages:
link:https://pypi.org/project/subsonic-connector/0.1.11/[subsonic-connector version 0.1.11] and
link:https://pypi.org/project/py-sonic/[py-sonic].

Only a limited set of features are currently available:

- List Newest Albums
- List Random Albums
- List Recently Played Albums
- List Genres: each Genre return Albums and the relevant Artists
- List Artists (All)
- List Artists (By Initial)
- List Playlists
- Search Albums
- Search Tracks
- Search Artists

Clicking on a Genre will show a list of albums belonging to that genre.

Enable this function by uncommenting the bogus setting for the `subsonicuser` variable
in the upmpdcli configuration file.
So will also need to specify:

- subsonicbaseurl
- subsonicport
- subsonicuser
- subsonicpassword

For example if your server is https://my-navidrome.mydomain.com, you will need to set

- subsonicbaseurl = https://my-navidrome.mydomain.com
- subsonicport = 443

if your server is http://my-navidrome.homelab.local:4533, you will need to set

- subsonicbaseurl = http://my-navidrome.homelab.local
- subsonicport = 4533

Consider that mpd will need to access those url, as well as your phone/tablet if you
plan to use BubbleUpnpServer. Consider using ip addresses if your android phone has difficulties
resolving local network hostnames. If this happens, you might not be able to see the
album covers, for example.

There are currently a few additional configuration parameters in the <<subsonicuser,configuration section>>.  

'''
[[UPMPDCLI-MS-STR]]
=== Streaming Services
  
The Media Server function in Upmpdcli gives access to external streaming services: Highresaudio and
Qobuz currently work fine (1.6.2).

The Deezer plugin works for low quality (but still usable) streams (128 kb/s mp3).

NOTE: I am not sure about Tidal support: in any case it will only work if you can find a working
application token, and even then, maybe not as their access control API is evolving. I have no
access to an API key, so I can't even test.

You will need a valid subscription for any service that you want to use.

Streaming is not limited to the local Upmpdcli Renderer, and the Media Server will happily send
music to other Renderers (within the limitations set by the service).

Two conditions must be true for the Media Server to appear with an entry for a streaming service:

 - The code for the service plugin must be installed. This comes generally
   in a separate package (e.g _upmpdcli-qobuz_).
 - The user variable for the service must be present in the configuration
   file (e.g `qobuzuser`).

Some other parameters (e.g. a password) may be needed for the access to
work, depending on the specific service. See the service-specific notes below.

There are several possible approaches for proxying access to streaming services. We have a little
more detailed documentation in a xref:UPMPDCLI-MS-STR-UPNP[separate section].

NOTE: The streaming services passwords are stored in the upmpdcli
configuration file ('/etc/upmpdcli.conf'). The installer does not make this
file r/w by owner only. You should probably change the mode after setting
the password: `chmod&#160;600&#160;/etc/upmpdcli.conf`.

NOTE: I have no reason to believe that upmpdcli is technically mis-using the streaming services in
any way, but it is definitely not approved by any of them, and you are using it under your own
responsibility.

////

==== Using Tidal through the Upmpdcli Media Server

NOTE::
Accessing Tidal needs an API key, and I don't have one. The module may still work for you if you
have key, but I am unable to test it.

[NOTE]
=====

There seems to sometimes be problems when streaming Tidal lossless/FLAC streams, with
the default MPD configuration. A preliminary and rather superficial enquiry seems to indicate that
this is caused by too much buffering by MPD. Adding the following parameters to the MPD
configuration file (/etc/mpd.conf) reduces the pre-fetch period and seems to fix the issues for me
(YMMV...):

    audio_buffer_size "2048"
    buffer_before_play "20%"

=====

You will need to install the upmpdcli-tidal module.

The Tidal module code is is based on the link:https://github.com/tamland/kodi-tidal[Kodi Tidal
add-on] and the link:https://github.com/tamland/python-tidal[Tidal API], by Thomas Amland (also
using other useful modules by Thomas). I was able to reuse most of the Kodi code. The Tidal api
module was recently updated and the login code comes from
link:https://github.com/arnesongit/kodi-tidal[this Git repository]. The software is not officially
supported by Tidal, and may just stop to work one day...

It only works with a valid Tidal subscription and valid Tidal API token, which you must set in the
`tidalapitoken` configuration variable.

The configuration parameters are described in the <<tidaluser,configuration section>>

////


'''
[[UPMPDCLI-MS-STR-QOBUZ]]
=== Qobuz

This is based on the service API from the link:https://github.com/tidalf/plugin.audio.qobuz[Kodi
add-on], by Joachim Basmaison and Cyril Leclerc, with the upper-level code adapted from the Tidal
add-on. The WEB API is not officially supported by Qobuz, and may just stop to work one day.

NOTE: The plugin uses the `requests` Python3 package, which is usually installed as a package
dependency. Else install it from Pypi.

NOTE: the Qobuz search does not allow searching a specific field (like the artist name or song
title). All objects matching a query in any field are returned. This means that, e.g., the field
choice of upplay search is ignored.

You need a valid Qobuz subscription.

Enable this function by installing the upmpdcli Qobuz module (which may be a separate package,
e.g. upmpdcli-qobuz on Debian), and adding your login and password to the configuration (as
`qobuzuer` and `qobuzpass`).

The configuration parameters are described in the <<qobuzuser,configuration section>>

If you are using the Linn Kazoo Control Point, upmpdcli has support for the `Credentials` service,
which facilitates configuration. Details xref:UPMPDCLI-MS-STR-CRED[here].


'''
[[UPMPDCLI-MS-STR-DEEZER]]
=== Deezer

You will need a premium (paid) account.

The plugin is based on code from the link:https://github.com/Valentin271/DeezerKodi.git[Kodi
add-on], by Jakub Gawron (kubatek94) and ? (Valentin271).

It uses the Deezer "television" API and only provides access to 128 kb/s MP3 streams.

NOTE: The plugin uses the `requests` Python3 package, which is usually installed as a package
dependency. Else install it from Pypi.


Enable this function by installing the upmpdcli Deezer module (which may be a separate package,
e.g. upmpdcli-deezer on Debian), and adding your login and password to the configuration.

The configuration parameters are described in the <<deezeruser,configuration section>>. Only
`deezeruser` and `deezerpass` actually.


'''
[[UPMPDCLI-MS-RADIO-BROWSER]]
=== radio-browser.info

The plugin allows access to the link:https://www.radio-browser.info/[Radio Browser] Web radios
catalog. Radios can be selected by country, language and tag, and/or searched for by name.

This uses the link:https://pypi.org/project/pyradios/[pyradios] Python module.

NOTE: `pyradios` is usually not packaged by the Linux distributions (e.g. Debian). You need to
install it separately, using, e.g. `pip3`.

Then enable the function by installing the upmpdcli radio-browser module (which may be a separate
package), and uncommenting the bogus setting for the `radio-browseruser` variable in the upmpdcli
configuration file.

There are currently no additional configuration parameters. Any would go in the
<<radio-browseruser,configuration section>>.  


'''
[[UPMPDCLI-MS-BBC]]
=== BBC Sounds

The plugin allows access to the link:https://www.bbc.co.uk/sounds[BBC Sounds] resource for listening
to past BBC programs. It normally lists the 30 previous days, this can be changed with a
<<bbcuser, configuration variable>>.

Enable this function by installing the upmpdcli BBC module (which may be a separate package,
e.g. `upmpdcli-bbc` on Debian), and uncommenting the bogus setting for the `bbcuser` variable
in the upmpdcli configuration file.

The configuration parameters are described in the <<bbcuser,configuration section>>. 

NOTE: the plugin needs the installation of additional Python3 packages, which may or may not be
packaged by your distribution. link:https://pypi.org/project/beautifulsoup4/[beautifulsoup4 (aka
bs4)],  link:https://pypi.org/project/python-dateutil/[dateutil],
link:https://pypi.org/project/feedparser/[feedparser], and
link:https://pypi.org/project/requests/[requests]. Install them as packages if possible, else, from
Pypi. 


'''
[[UPMPDCLI-MS-UPRADIOS]]
=== Upradios radio list

This is a minuscule plugin which just exports the Upmpdcli <<radio-stations,radio list>> as a
playlist, so that other renderers on the network can use it.

Because just the stream URL is computed/used, the functionality is reduced when compared to using
Upmpdcli OpenHome Radio service: there will be no dynamic art or special metadata features:
`artScript` and `metaScript` entries are just ignored.

Still, the server will convert .pls and other playlist entries into actual
stream URLs, and it may be convenient for maintaining the radio list in one
place.

Enable this function by installing the upmpdcli Radios module (which may be a separate package,
e.g. upmpdcli-radios on Debian), and uncommenting the bogus setting for the 'upradiosuser' variable
in the upmpdcli configuration file.

The configuration parameters are described in the <<upradiosuser,configuration section>>. 


'''
[[UPMPDCLI-CONFIGURATION]]
== Configuration file reference

A description of upmpdcli configuration variables follow. As of upmpdcli 1.6.0, all
values can also be set through environment variables named UPMPD_XXX where XXX is the
upper-cased version of the variable name (Ex: loglevel -> UPMPD_LOGLEVEL).

In the case where a variable is set in several ways, the order of precedence is: command line
(highest), configuration file, environment.

If used, the configuration file name can be set either with the `-c` command line option or through
the `UPMPD_CONFIG` environment variable.

include::upmpdcli-config.txt[]


[[UPMPDCLI-PACKAGES]]
== Installation from packages

The link:https://www.lesbonscomptes.com/upmpdcli/pages/downloads.html[upmpdcli
downloads page] has a number of pointers to binary packages for a number of
common distributions (Debian, Raspbian, Ubuntu, Fedora) and architectures
(ARM and x86).



[[UPMPDCLI-BUILDING]]
== Building from source


=== Running upmpdcli on Android

We've had an link:https://framagit.org/medoc92/upmpdcli/-/issues/67[adventurous user] building and
running upmpdcli on Android. The main gotcha seems to be that you will need to add the upmpdcli user
to appropriate groups to allow it to open TCP sockets. See the issue entries for details.

=== Building upmpdcli on Linux

For building from source, you will need a C\++ compiler with full
C++11 support, and the development packages for the supporting libraries:
*libcurl*, *libmicrohttpd*, *libmpdclient*, and *libexpat*.

Also the Python modules for streaming service support use the
*python3-requests* package, so you may need to install it (it is only needed
at run time). 

If you are using the source from the git repository, you will also need the
*autoconf*, *automake*, *libtool* trio. Use the `autogen.sh` script to set
things up.

So you need to either clone 3 git repositories:

- https://framagit.org/medoc92/npupnp
- https://framagit.org/medoc92/libupnpp
- https://framagit.org/medoc92/upmpdcli

or download the release tar files from the the
link:https://www.lesbonscomptes.com/upmpdcli/pages/downloads.html[upmpdcli
download page]

For upmpdcli, there are two specific configure options. Each needs the
installation of additional dependancies:

- --enable-confgui: build the configuration editor GUI. This will need
the Qt development packages
  
Once the source is extracted, the procedure is standard for each of the
three packages:

    # Only for git source
    sh autogen.sh 

    ./configure --prefix=/usr --sysconfdir=/etc [other options]
    make
    sudo make install

Which you should apply first to the *libnpupnp* source, then to *libupnpp*,
then to *upmpdcli*.

If you omit the `--sysconfdir=/etc` part, `upmpdcli.conf` will end up in
`/usr/etc/`, which is ok, but confusing, as package installers put it in
`/etc/`

==== Boot time startup

*upmpdcli* will try to change its `uid` to user `upmpdcli` if it is
started by root. It will refuse to run if the user does not exist.

If started by `root`, *upmpdcli* will also write its process id to
`/var/run/upmpdcli.pid`.

There are boot-time startup scripts in the `debian/` directory inside the
source tree (for Debian/Ubuntu/Mint/Raspbian etc.). There is also a systemd
service file under `systemd/` (for Fedora et al.).

The boot scripts are installed by the pre-built packages, so will just have
to edit the configuration file after installing them, all the rest should
just work.


////
Completely obsolete
=== Building libupnpp and upmpdcli on Mac OS X

I don't run Mac OS X and I can't support this directly. However a kind user
has provided a
link:https://opensourceprojects.eu/p/upmpdcli/tickets/3/[build recipe]
based on homebrew.

You will first need to apply the patches from
link:https://www.lesbonscomptes.com/upmpdcli/files/2017-12-upmpdcli-macos-build-patches.tgz[this
file].

Then:

----
brew install mpd
brew install autoconf
brew install automake
brew install libtool
brew install libupnp libmpdclient expat jsoncpp libmicrohttpd expat curl
brew install pkg-config
brew install expat
export PKG_CONFIG_PATH=/usr/local/opt/expat/lib/pkgconfig
configure --prefix=/usr
make
----
////


=== Building OpenHome and sc2mpd

There are two parts in building *sc2mpd*:

- Building the Openhome libraries
- Building *sc2mpd* proper

First download a
link:http://www.lesbonscomptes.com/upmpdcli/pages/downloads.html[*sc2mpd*
release] or clone the *sc2mpd*
https://framagit.org/medoc92/sc2mpd[Git repository].


==== Creating the the OpenHome source tree

Building the Openhome libraries is a bit of a black art for a number of
reasons:

- There are no released distributions for the OpenHome libraries, but
  only a number of git repositories for the different components. The state
  of the repositories is not completely consistent at all times (there will
  be moments when a component will not build with another).
- The OpenHome build system is very complicated because it works on
  multiple platforms and multiple language bindings.

The first step is to create the openhome source tree. There are two
possible ways, described just below.

In both cases, after creating the tree, you need to compile the openhome
software. See the sc2mpd build section below.

===== OpenHome source tree, the easy way

Download the tar file of the appropriately patched openhome code from the
upmpdcli downloads page (use the current one, the date on the one below is
just an example), create an empty directory, untar it in it

    cd /home/me
    mkdir openhome
    cd openhome
    tar xf /path/to/openhome-sc2-20210305.tar.gz
    
===== OpenHome source tree, the complicated way

The *sc2mpd* source comes with a shell script named _ohbuild.sh_ to help
with this. It has several functions:

 - Cloning the OpenHome and checking out verified revisions
 - Applying a few minor patches to ensure that the build will work in a
   simplified environment (e.g. without a c# compiler).
 - Creating a tar file of a compact trimmed tree.
 - Running the build either from the cloned tree or the tar file.

The tar functions are mostly useful to help with building packages. For a
normal build, the procedure would be as follows:

    cd sc2mpd
    mkdir /my/place/for/openhome
    sh ohbuild.sh -b /my/place/for/openhome

NOTE: for sc2mpd 1.1.7 you will need to copy the ohpatches directory from
the git code directory to the extracted tar file directory because I forgot
to include it in the distribution.


==== Building sc2mpd

*sc2mpd* depends on a number of libraries, which are usually packaged on
Linux, and which you need to install first:

- The link:http://www.gnu.org/software/libmicrohttpd/[microhttpd]
  library. Install the development and runtime packages which are currently
  named _libmicrohttpd-dev_ and _libmicrohttpd10_ on Debian-derived systems
  (use _libmicrohttpd_ and _libmicrohttpd-devel_ for Fedora).
- The link:http://www.mega-nerd.com/SRC/[libsamplerate]
  library (_libsamplerate0_ on Debian, _libsamplerate-devel_ for Fedora).
- The *libasound* Alsa interface library (_libasound2-dev_ on Debian,
  _alsa-lib-devel_ for Fedora).

First build openhome. Change your current directory to the top of the
sc2mpd source tree, then run:

    sh ohbuild.sh /my/place/for/openhome

Once OpenHome is built and the auxiliary library development packages are
installed, build *sc2mpd*, using the following commands inside the
_sc2mpd_ directory (you only need the autogen part for a cloned git tree,
not for a tar extraction):

    sh autogen.sh
    ./configure --prefix=/usr --with-openhome=/my/place/for/openhome
    make
    sudo make install

The build uses static Openhome libraries, so you can move the executable to
another machine without needing the Openhome directory (don't forget to
install the _libmicrohttpd_, _libsamplerate_ and _libasound_ runtimes
though).

After restarting *upmpdcli*, it should advertise the _Receiver_ service and
appear in the Songcast Sender menus.

==== Building a Debian package from an sc2mpd tar distribution

Here follows a synopsis of building a debian package for an sc2mpd tar
distribution. You'll need to replace the 1.1.1 and 20151223 versions with
whatever you are building. Note that the 1.1.1 value must match what you
have in the Debian changelog (or update the changelog).

The $distdir and $sc2mpd_src values stand for places where you store the tar
files and the sc2mpd (git) source tree.

    mkdir sc2mpd_build
    cd sc2mpd_build
    cp $distdir/sc2mpd-1.1.1.tar.gz sc2mpd_1.1.1.orig.tar.gz
    cp $distdir/openhome-sc2-20180615.tar.gz sc2mpd_1.1.1.orig-openhome.tar.gz
    tar xzf sc2mpd_1.1.1.orig.tar.gz
    cp -rp $sc2mpd_src/debian sc2mpd-1.1.1/
    cd sc2mpd-1.1.1
    mkdir openhome
    cd openhome
    tar xzf ../../sc2mpd_1.1.1.orig-openhome.tar.gz
    cd ..
    debuild

////
[[SPOTIFY-AUTH]]
== Annex: setting up Spotify access authorization

Upmpdcli uses a hybrid approach for accessing Spotify: it uses the newer
WEB API for browsing the catalog, and the old libspotify library for
streaming.

As a consequence, two sets of authorization parameters must be specified:
the library uses a classical user name ` password pair, to be set in the
<<spotifyuser,configuration file>>.

The WEB API uses a more modern (and more ennoying) oauth2
authentification/authorization method. This needs to go through a WEB
browser. You will need to execute the following steps to set things up:

- Download the
  link:http://www.lesbonscomptes.com/upmpdcli/files/upmpdcli-spotify-authinit.zip[zip
  file for the helper script]. Right-click the link and use `Save link as`.
- Unzip the file on any Linux machine with a web browser. This will create
  a 'upmpdcli-spotify-authinit' directory. The chosen machine can be the
  host where upmpdcli runs, or not: any Linux machine with a browser will do.
- Check that the python3-requests package is available on the chosen host, or
  install it.
- Run the helper script inside the unzipped directory. Replace 'username'
  with your Spotify user id.
  
    ./spotiauthinit.py username

- The script will start a Web browser, and you will be asked to log in to
  Spotify and authorize upmpdcli to access your data.
- At the end of the web interaction, you will be redirected to a
  non-existing page (an error will be displayed in the browser). Copy the
  link address from the address bar, and paste it to the spotiauthinit.py
  input line (you will have been prompted to do this by the script).
- The script will then store the authorization token in a file named
  '/tmp/spotipy-<username>-token', which you will need to copy to the host
  where upmpdcli run, and move it to a file named
  '/var/cache/upmpdcli/spotify/token', or, if you changed the value of the
  `cachedir` parameter, to '[cachedir]/spotify/token'.
- Make sure that /var/cache/upmpdcli and its contents belong to upmpdcli:

    sudo chown -R upmpdcli /var/cache/upmpdcli/spotify
////


[[UPMPDCLI-MS-STR-UPNP]]
==== Technical note: Streaming Services and UPnP

Streaming services like Qobuz or Highresaudio give access to a huge catalog of music through a WEB
programming interface which may be also usable by programs other than their own applications.

Upmpdcli offered a gateway for quite a few of these services in the past. Unfortunately, changes in
some of the service APIs have made it impossible to access them from an open-source
application (Tidal, Spotify), and only a few remain, sometimes with restrictions (Deezer).

The only thing that the services interfaces have in common with UPnP is that most of them use HTTP
to retrieve the audio stream (as a short-lived URL). Spotify was an exception, and used a specific
protocol for streaming (this was finally deprecated in 2022).

Given the importance of these services for music consumers, many UPnP Control Points and Renderers
have been extended with specific interfaces to the different services. In many cases, this is only
feasible from a closed-source application, with an agreement with the service providers, to hide
"secrets" inside the app.

There are three main ways to integrate the streaming services in an UPnP framework, and knowing
which way you are using will avoid confusion:

- The first approach is to have a UPnP Media Server act as a proxy for the service: the catalog is
  browsed through a standard UPnP interface (the Media Server translates this to the service API
  behind the scenes), and the audio URIs are also accessed in an almost standard way (after a bit of
  magic inside the Media Server). The one inconvenient of this approach is that the special
  functions of the service (like managing the user favourites lists) are mostly inaccessible. The
  advantage is that any naive UPnP Control Point can access the streaming service. The Media Server
  inside upmpdcli xref:UPMPDCLI-MS-STR-UPNP[implements this method].

- The second approach is to do everything inside the Control Point. The CP uses the service API for
  browsing (and possibly do things like managing favourites). The CP also mediates the HTTP access
  to the audio streams (the URIs the CP sends to the Renderer point to itself, and it arranges to
  forward the data from the service). This is implemented, for example, by Bubble UPnP. The drawback
  of this approach is that the Control Point device must not go to sleep or out of reach, else the
  music will stop (maybe at the next track).

- The third approach is to distribute the function between CP and
  Renderer. The Control Point performs the browsing and access to special
  functions, and the Renderer knows how to access the service streams. This
  is the OpenHome approach and can be considered the best of both worlds,
  at the price of complexity and compatibility issues. This method is
  implemented by the Linn Kazoo Control Point, and a number of Renderers,
  the Linn and Lumin ones of course, but also,
  xref:UPMPDCLI-MS-STR-CRED[lately by upmpdcli]. +
  * At the moment, the upmpdcli implementation only works for Qobuz, as
    changes in the Tidal access method have made it impossible to support.



[[UPMPDCLI-MS-STR-CRED]]
==== Accessing Qobuz with OpenHome from Kazoo

This implements the `OpenHome Credentials` service and only works for Qobuz at the moment (it may
work for Tidal if you have found an API token or appid/secret pair, but I can't test this). The
corresponding media server module must be installed (upmpdcli-qobuz), but no other configuration
should be necessary on the renderer.

This should also work with Lumin devices, but it does not currently, the reason is unknown. When
feature is active, it actually prevents Lumin from discovering upmpdcli at all, so there is a
configuration variable to disable it: '`lumincompat`'. Set to 1 to use upmpdcli v1.3.0 with Lumin.

Upmpdcli uses the *openssl* command to perform the cryptography work. This was not made a hard
dependancy, so you should check that it is installed. 

The media service icons will appear in the Control Point interface, and the service will be
accessible after entering the login and password.

NOTE: the user name and password will be stored on the renderer in an insecure way, meaning that if
someone steals the machine or obtains root access, there is nothing to prevent them from getting the
credentials.

Of course Kazoo or Lumin can also access the services through the media server interface (after
configuring upmpdcli, see the xref:UPMPDCLI-MS-STR-UPNP[previous section]).

For reference, this method is *not* usable with *Upplay*

The notes which follow relate to accessing the services through the Upmpdcli Media Server.

[[SC2MPD-INSTALL]]
== Annex: Songcast installation walkthrough

If you want to play from a Mac or Windows machine, install the 
link:http://www.linn.co.uk/software#songcast[Songcast application]

NOTE: Not all http://oss.linn.co.uk/Releases/Songcast/Davaar/[Songcast
capture application versions] work well with upmpdcli. Lately (03-2017),
the latest version (4.8.535) seems to work fine. In the past, I've had good
luck with 4.4.190 but not with the 4.5 ones (it is possible to get them to
work with *upmpdcli* from the *upplay* control panel, but the Windows app
claims that the *upmpdcli* receiver is unavailable.).

I could not get IP multicast to work with WIFI Receivers (the sound drops
constantly).

There are well-known problems with multicast and WIFI (see for example
http://superuser.com/questions/730288/why-do-some-wifi-routers-block-multicast-packets-going-from-wired-to-wireless[this
superuser.com question] 
for detailed explanations). This seems to be dependant on the WIFI hardware
(router/access points) used, so maybe you will have more luck than me.

If some of your Receivers use WIFI, and you experience sound issues, check
that "Unicast" is selected in the Songcast configuration "advanced" panel
on the desktop.

Under most conditions, WIFI data rates should be more than sufficient to
transport Songcast streams (a bit over 1 Mbit/S for 48k/24bits, 700 Kbits/S
for 44.1k/16 bits).

However, Songcast is probably best transported over a wired connection. If
you are doing this over WIFI and experiencing glitches, the wireless is the
first suspect.

If the Sender is a *upmpdcli* host, you should probably also install the
link:http://www.lesbonscomptes.com/upplay/[upplay] Control Point
somewhere. Recent upplay versions include a tool to control Sender and
Receiver instances. This is less necessary if the Sender is on Windows or
Mac, as the Songcast application on these platforms includes a limited
connection tool (no multiroom).

Download and install the *upmpdcli* and *sc2mpd* packages for your Linux
system. See
link:http://www.lesbonscomptes.com/upmpdcli/pages/downloads.html#packages[the
download page here].

When using a single Receiver, things should just work, the _UpMpd_
Receiver should appear in the Songcast app on the host (or in the *upplay*
control panel).

WARNING: There is *no software volume control* for the *upmpdcli* Songcast
Receivers for now: use either a local mixer or the little round things on
the pre-amps. Set the volume low when experimenting !

NOTE: The receiver side does not work too well on Raspberry Pis using an
USB DAC (as far as I could see). The reason may be that the data rate of
the uncompressed stream is just too much for the poor Pi Ethernet/USB
chip. Things work just fine with an I2S DAC (or on HDMI probably). When on
WIFI, the results are sometimes irregular too, depending on the quality of
the connection. If you have no Ethernet cabling, Ethernet over power lines
may work better than WIFI. The best combination of network and DAC link is
definitely Wired and I2S (or HDMI).

When using multiple Receiver instances, you need to at least customize
their names, and you want to take care of synchronization issues. You will
need to take a look at a bit more documentation:

 - xref:friendlyname[`friendlyname`]
 - xref:UPMPDCLI-MULTIROOM-SYNC[audio synchronization issues and *sc2mpd*
   configuration].


[[SENDER-EXTSOURCES]]
== Annex: Setting up external audio sources for the Songcast Sender

The *upmpdcli* Sender modes are controlled by switching OpenHome
Sources. By default, and if the *sc2mpd* package is installed, *upmpdcli*
will create 'PL-to-Songcast' and 'RD-to-Songcast' sources for broadcasting
its playlist or radio streams to Songcast.

As explained in the main body, there is nothing magical with this: *mpd*
just streams to a FIFO which is read by the *mpd2sc* command, which then
broadcasts it. This pipe is set up by a script (_scmakempdsender_).

Under certain conditions, if *upmpdcli* finds other scripts in a designated
directory, it will create more sources, and start them when the
corresponding source is selected (of course, it expects the script to
create a Songcast Sender pipe).

The *upmpdcli* source comes with a sample script which sets things up for
*mpd2sc* to read *arecord* output, allowing multiroom playing of an
external analog source (line-in). The sample script is flexible enough to
manage different inputs without code changes, and there are comments at the
top which give detailed explanations. The parts of more general interest
will be a bit expanded here (see below). If you want to use the script
itself, you need to look at the comments. You will find the script under
'samplescripts/Analog-Input' in the source tree.

Based on the same mechanism (but quite different code inside the script)
there is also a nice
link:https://www.lesbonscomptes.com/upmpdcli/github-issues/upmpdcli-html/issue-71.html[HOWTO]
explaining how to link a Bluetooth device to Songcast.

The general idea is that upmpdcli will create an Openhome Source for each
script it finds inside a designated directory. By default, the directory is
`/usr/share/upmpdcli/src_scripts`, but it can be changed by setting the
`ohsrc_scripts_dir` configuration variable inside `/etc/upmpdcli.conf`

For managing analog sources, entries inside the directory will typically
be created as symbolic links to the sample script, which is installed as
`/usr/share/upmpdcli/Analog-Input`. For doing other things, the scripts
will not be links, but they must still be named a bit specially.

The scripts (or links) must be named like _SourceType_-_SourceName_, where
_SourceType_ MUST BE one of `Analog`, `Digital`, or `Hdmi`, (which are all
the same, and for display purpose only), and you can choose _SourceName_ as
you wish, but it should contain no space characters.

The Source will appear with type `Analog`, `Digital` or `Hdmi` and name
_SourceName_ in an OpenHome Source select dialog (e.g from *upplay*).

The `Analog-Input` sample script has provisions for reading the device name
and setup/teardown instructions from external files, so that it does not
need to be modified. This is only relevant for the sample, please have a
look at the comments for details.

[[RADIO-SCRIPTS]]
== Annex: the radio scripts

=== The radio URL script

The `url` field inside the radio definition can be a direct audio link or a
link to the radio station playlist. This link will be interpreted by the
'fetchstream.py' ('rdpltostream' directory inside the source tree, or see
'/usr/share/upmpdcli/rdpl2stream'). The Python code knows about the various
playlist formats used by the stations.

=== The dynamic album art script

If set, `artScript` is the path to an executable script which can retrieve
the image URL for the currently playing title. It can also be a simple
script name if this is located in the PATH or in the 'radio_scripts'
directory inside the upmpdcli directory (typically '/usr/share/upmpdcli').

Some radios (e.g.  link:https://www.radioparadise.com/rp_2.php?#[Radio
Paradise]) publish the album art for the currently playing title. The
details vary. The `artScript` parameter, if set, should point to an
executable script which prints this dynamic art Uri to stdout. The image
will supercede the radio logo, to be displayed by control points. Beware
that the path to the script must be accessible by the _upmpdcli_ user,
which may not be the case for your home. `/usr/local/bin` is your
friend. The Upmpdcli installation has a very small set of scripts inside
the '/usr/share/upmpdcli/radio_scripts' directory. This includes a very
rough example for retrieving the Radio Paradise art URI,
'radio-paradise-get-art.sh' 

The art script is executed each time the stream metadata changes (the data
is obtained by mpd from Icy metadata in the stream).

Upmpdcli does not set a timeout for the `artScript` execution. A reasonable
value should be used inside the script, to avoid freezing upmpdcli forever.

There is no reason to have an `artScript` if `metaScript` exists for the
radio. `metaScript` can also return the image URL.

=== The dynamic metadata script

If set, `metaScript` is the path to an executable script which can retrieve
the metadata (possibly including art Url) for the currently playing
title. It can also be a simple script name if this is located in the PATH
or in the 'radio_scripts' directory inside the upmpdcli directory
(typically '/usr/share/upmpdcli').


The script should output the metadata in JSON format. An example output
follows (the newlines and whitespace are just here for readability, any
valid JSON will do):

----
{
    "title" : "The title of the current track",
    "artist" : "The artist playing",
    "album": "The album name",
    "artUrl" : "https://www.somesite.com/path/to/image.jpg",
    "audioUrl" : "http://some url",
    "reload" : 103
}
----

The `reload` value gives the number of seconds after which the script
should be re-executed (the clever radio sets this to the remaining song
time). By default, the script is executed every 10 S.

Any value not present will simply not be used (not an error). `audioUrl` is
generally not set. If it is set, it's the next audio Url to queue after the
current one (this is used for radio streams which are a sequences of URLs
rather than a continuous stream, for example the Radio Paradise FLAC
station).

The 'radio_scripts' directory has two examples of radio metadata scripts, a
simple one ('fip-meta.py'), and a quite complicated one
('radio-paradise-get-flac.py'). Both need the Python3 'requests' package to
be installed.


[[COMMAND-ENVIRON]]
== Annex: command line and environment

In most situations, *upmpdcli* will be run as follows:

    upmpdcli -c /etc/upmpdcli.conf

The `-c` option specifies a configuration file.

See the upmpdcli(1) manual page for more information about the command line.

Some of the essential configuration parameters can be set either from the command line, a
configuration file, or the environment in this order of priority. It would be rather confusing to
use a mix of methods, so you should probably chose one.

As of upmpdcli 1.6.0 *all* configuration variables can be set through the environment instead of as
a configuration file entry. The set of variables which can also be set from the command line is
unchanged. In case of multiple settings, the precedence is as above (command line, configuration
file, environment).

All parameters have defaults, and a minimal installation will need no customisation at all.

|========================
|What|Command line|Environment|Config variable
|Configuration file name|-c config|$UPMPD_CONFIG|
|Host name or IP address where *MPD* runs|-h mpdhost|$UPMPD_HOST or (1.6) $UPMPD_MPDHOST|mpdhost
|TCP port for *MPD*|-p mpdport|$UPMPD_PORT or (1.6) $UPMPD_MPDPORT|mpdport
|UPnP "friendly name" for the device. This gets displayed in network search
  results.|-f friendlyname|$UPMPD_FRIENDLYNAME|friendlyname 
|Log file name. Leave empty for stderr|-d logfilename|(1.6) $UPMPD_LOGFILENAME|logfilename
|Verbosity level (0-4)|-l loglevel|(1.6) $UPMPD_LOGLEVEL|loglevel
|UPnP network interface|-i iface|$UPMPD_UPNPIFACE|upnpiface
|UPnP port|-P port|$UPMPD_UPNPPORT|upnpport
|========================


[[UPMPDCLI-CONFIG-GUI]]
== Annex: the upmpdcli-config GUI configuration editor.

The upmdpcli-config tool presents a graphical interface for creating an
upmpdcli configuration file. It presents different tabs with controls,
directly matching the organisation of the parameters in the documentation.
Both the tool and the manual are generated from data in the reference
configuration distributed with the package (typically
'/usr/share/upmpdcli/upmpdcli.conf-xml').

You can use the tool to create a configuration from scratch (just tweak
what you want, then save the file), or for editing an existing
configuration. The latter can be done either by passing the configuration
file name on the command line, or by using the 'Open' menu entry. If you
use the command line, the parameter automatically becomes the target of a
future 'Save' command (you can change it by using 'Save as'). When using
'Open', you will be asked to choose an output destination when saving.

Each control has a label, and an longer explanation in a tooltip, which you
can see by leaving the cursor on the label. 

Once you are satisfied with the changes, you can save the file, and move it
to its normal location if needed (e.g. '/etc/upmpdcli.conf').

Only the parameters which were changed in the configuration you edit (if
not starting from scratched), and those which you change through the
interface, will be saved to the output. Parameters unchanged from the
defaults will not appear at all, allowing for a less cluttered file.

[[SCWEB]]
== Annex: the scweb Songcast control interface.

This is only useful if you have no machine on which to run *upplay*, or
*Bubble DS Next*. Either are easier to use than the web
tool.

To avoid having to access the command line interface to control the
*Songcast* groups, *upmpdcli* comes with a small Web server which uses
*scctl* to actually do the work. This is found inside the `web/`
subdirectory inside the *upmpdcli* source tree.

The server is based on the 
link:http://bottlepy.org/docs/dev/index.html[Bottle Python Web Framework]
and it only depends on Python 3.

You can use the `scweb-standalone.py` script to manually start the
interface:
    
    python3 ./scweb-standalone.py

This will start a server on localhost, on port 8680 by default which is
good for testing, but not very useful. Use the -a 0.0.0.0 option to let the
server answer on all local addresses (or specify the address to use a
specific interface):

    python3 ./scweb-standalone.py -a 0.0.0.0

-p can be used to specify a port.

Once started, connecting to the server from any browser should hopefully
display a reasonably self-explanatory interface.

Recent *upmpdcli* packages install the web app as a service named
*scweb*. The service is not started by default though, you need to edit
`/etc/default/scweb`.

